# frozen_string_literal: true
module BidirectionalLinksGenerator
  class BidirectionalLinksGenerator < Jekyll::Generator
    def generate(site)
      graph_nodes = []
      graph_edges = []

      # all_notes = site.collections['_posts'].docs
      all_notes = site.posts.docs
      all_pages = site.pages

      all_docs = all_notes + all_pages
      # print all_docs
      puts "Generating bidirectional links..."
      puts "#{site.baseurl}"

      autogenerated_links_begin = '[//begin]: # "Autogenerated link references for markdown compatibility"'

      # link_extension = !!site.config["use_html_extension"] ? '.html' : ''

      # Replace double bracket links with links from wikilinks definitions between [//begin]:[//end]
      all_docs.each do |current_note|
        doc_content = current_note.content.split(autogenerated_links_begin)
        # iterate over the lines in doc_content[1] to find the end of the link definitions
        if doc_content.length > 1
          links = doc_content[1].scan(/\[(.*?)\]: (.*?) "(.*?)"/)
          links.each do |link|
            link_title = link[0]
            link_href = link[1].gsub(/\.md/, '')
            link_text = link[2]
            doc_content[1].gsub!(/#{link[1]}/i, "/#{link_href}/")
          end
          current_note.content = doc_content[0].concat(autogenerated_links_begin).concat(doc_content[1])
        end
      end

      # puts all_docs

      # Identify note backlinks and add them to each note
      all_docs.each do |current_note|
        begin
          if current_note.path.end_with?('.md')
            # Nodes: Jekyll
            note_name = current_note.url.scan(/[\w\-]+\/$/)
            notes_linking_to_current_note = all_docs.filter do |e|
              e_content = e.content.split(autogenerated_links_begin)
              if e_content.length > 1
                begin
                  e_content[1].include?("#{note_name[0]}") if e.path.end_with?('.md')
                rescue NoMethodError => err
                  puts "Error: #{err}, (#{current_note.url})"
                end
              end
            end
            puts "notes linking to #{current_note.url} (#{note_name[0]}): #{notes_linking_to_current_note}"
          end
        rescue NoMethodError => e
          puts "Error: #{e}, (#{current_note.url})"
        end

        # Nodes: Graph
        
        current_note_name = ''
        begin
          current_note_name = current_note.name.gsub(/\.md/, '')
        rescue NoMethodError => e
          current_note_name = current_note.url.gsub(/\//, '-')
        end

        graph_nodes << {
            id: note_id_from_note(current_note),
            path: "#{site.baseurl}#{current_note.url}",
            label: current_note_name
          } if current_note.path.end_with?('.md')


        # Edges: Jekyll
        current_note.data['backlinks'] = notes_linking_to_current_note

        begin
          # Edges: Graph
          notes_linking_to_current_note.each do |n|
            graph_edges << {
              source: note_id_from_note(n),
              target: note_id_from_note(current_note),
            }
          end
        rescue NoMethodError => e
          puts "Error: #{e}"
        end
      end

      File.write('_includes/notes_graph.json', JSON.dump({
        edges: graph_edges,
        nodes: graph_nodes,
      }))
    end

    def note_id_from_note(note)
      note.url.bytes.join
    end
  end
end